import os
import sqlite3
import subprocess
import tkinter as tk
from tkinter import filedialog, ttk, messagebox
import shutil
import tempfile
import gc

# --- CONFIG ---
TOOL_PATH = os.path.join("SQLiteExporter", "SQLiteExporter.exe")

class CDBEditor:
    def __init__(self, root):
        self.root = root
        self.root.title("CDB Editor - Build 2.0")
        self.root.geometry("1100x750")
        
        self.original_cdb_path = None 
        self.temp_sqlite_path = None 
        self.current_table = None
        self.active_editor = None 

        toolbar = tk.Frame(root, pady=10)
        toolbar.pack(side=tk.TOP, fill=tk.X)
        
        tk.Button(toolbar, text="Open...", command=self.load_cdb).pack(side=tk.LEFT, padx=10)
        tk.Button(toolbar, text="Save as...", command=self.save_as_cdb).pack(side=tk.LEFT, padx=10)

        self.pw = tk.PanedWindow(root, orient=tk.HORIZONTAL, sashwidth=2, bg="gray")
        self.pw.pack(expand=True, fill=tk.BOTH)

        self.sidebar = tk.Listbox(self.pw, width=30)
        self.sidebar.bind("<<ListboxSelect>>", self.on_table_select)
        self.pw.add(self.sidebar)

        self.table_frame = tk.Frame(self.pw)
        self.pw.add(self.table_frame)

        self.tree = ttk.Treeview(self.table_frame, show="headings", selectmode="browse")
        self.vsb = ttk.Scrollbar(self.table_frame, orient="vertical", command=self.tree.yview)
        self.hsb = ttk.Scrollbar(self.table_frame, orient="horizontal", command=self.tree.xview)
        self.tree.configure(yscrollcommand=self.vsb.set, xscrollcommand=self.hsb.set)

        self.tree.grid(row=0, column=0, sticky='nsew')
        self.vsb.grid(row=0, column=1, sticky='ns')
        self.hsb.grid(row=1, column=0, sticky='ew')
        self.table_frame.grid_columnconfigure(0, weight=1)
        self.table_frame.grid_rowconfigure(0, weight=1)

        self.status = tk.Label(root, text="Ready", bd=1, relief=tk.SUNKEN, anchor=tk.W)
        self.status.pack(side=tk.BOTTOM, fill=tk.X)

        self.tree.bind("<Double-1>", self.on_double_click)

    def load_cdb(self, path=None):
        if not path:
            path = filedialog.askopenfilename(filetypes=[("CDB files", "*.cdb")])
        if not path: return
        
        self.original_cdb_path = os.path.abspath(path)
        temp_dir = tempfile.gettempdir()
        self.temp_sqlite_path = os.path.join(temp_dir, "pcm_working_db.sqlite")
        
        # Kill any existing editor and clear memory handles
        if self.active_editor: self.active_editor.destroy()
        gc.collect()

        try:
            local_sqlite = self.original_cdb_path.replace(".cdb", ".sqlite")
            subprocess.run([TOOL_PATH, "-a", "-export", self.original_cdb_path], check=True)
            
            # Move to Sandbox
            if os.path.exists(self.temp_sqlite_path): os.remove(self.temp_sqlite_path)
            shutil.move(local_sqlite, self.temp_sqlite_path)
            
            # Load sidebar
            with sqlite3.connect(self.temp_sqlite_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
                self.sidebar.delete(0, tk.END)
                for r in cursor.fetchall(): self.sidebar.insert(tk.END, r[0])
            
            self.status.config(text=f"Connected: {os.path.basename(self.original_cdb_path)}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load: {e}")

    def on_table_select(self, e):
        selection = self.sidebar.curselection()
        if not selection: return
        self.current_table = self.sidebar.get(selection[0])
        self.load_table_data()

    def load_table_data(self):
        if self.active_editor: self.active_editor.destroy()
        with sqlite3.connect(self.temp_sqlite_path) as conn:
            cursor = conn.cursor()
            cursor.execute(f"PRAGMA table_info([{self.current_table}])")
            cols = [c[1] for c in cursor.fetchall()]
            self.tree["columns"] = cols
            for c in cols:
                self.tree.heading(c, text=c)
                self.tree.column(c, width=150, stretch=False)
            self.tree.delete(*self.tree.get_children())
            cursor.execute(f"SELECT * FROM [{self.current_table}]")
            for row in cursor.fetchall(): self.tree.insert("", "end", values=row)

    def on_double_click(self, event):
        item = self.tree.identify_row(event.y)
        column = self.tree.identify_column(event.x)
        if not item or not column: return
        col_idx = int(column[1:]) - 1
        col_name = self.tree["columns"][col_idx]
        vals = self.tree.item(item, "values")
        pk_val = vals[0]
        x, y, w, h = self.tree.bbox(item, column)
        self.active_editor = tk.Entry(self.table_frame)
        self.active_editor.insert(0, vals[col_idx])
        self.active_editor.place(x=x, y=y, width=w, height=h)
        self.active_editor.focus_set()

        def commit(e=None):
            if not self.active_editor: return
            val = self.active_editor.get()
            with sqlite3.connect(self.temp_sqlite_path) as conn:
                conn.execute(f"UPDATE [{self.current_table}] SET [{col_name}]=? WHERE [{self.tree['columns'][0]}]=?", (val, pk_val))
                conn.commit()
            self.active_editor.destroy()
            self.active_editor = None
            self.load_table_data()

        self.active_editor.bind("<Return>", commit)
        self.active_editor.bind("<FocusOut>", commit)

    def save_as_cdb(self):
        if not self.temp_sqlite_path: return
        target = filedialog.asksaveasfilename(
            initialfile=os.path.basename(self.original_cdb_path),
            defaultextension=".cdb", filetypes=[("CDB files", "*.cdb")]
        )
        if not target: return
        
        target_abs = os.path.abspath(target)
        target_base = os.path.splitext(target_abs)[0]
        target_sqlite = target_base + ".sqlite"

        try:
            # --- CRITICAL: RELEASE ALL HANDLES ---
            self.tree.delete(*self.tree.get_children())
            if self.active_editor: self.active_editor.destroy()
            gc.collect() # Force-release the SQLite file handle in Python

            # 1. Copy Sandbox to Target Folder
            shutil.copy2(self.temp_sqlite_path, target_sqlite)
            
            # 2. Run Tool
            subprocess.run([TOOL_PATH, "-a", "-import", target_base], check=True)
            
            # 3. Cleanup
            if os.path.exists(target_sqlite): os.remove(target_sqlite)
            
            messagebox.showinfo("Success", "CDB overwritten and saved.")
            
            # 4. Re-Initialize to avoid "No Such Table" errors
            self.load_cdb(target_abs)
            
        except Exception as e:
            messagebox.showerror("Save Error", f"Overwrite failed: {e}")

if __name__ == "__main__":
    root = tk.Tk()
    app = CDBEditor(root)
    root.mainloop()